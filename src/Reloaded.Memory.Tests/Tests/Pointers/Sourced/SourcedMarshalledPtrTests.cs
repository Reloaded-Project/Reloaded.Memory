using System;
using FluentAssertions;
using Reloaded.Memory.Pointers;
using Reloaded.Memory.Pointers.Sourced;
using Xunit;

namespace Reloaded.Memory.Tests.Tests.Pointers.Sourced;

public unsafe class SourcedMarshalledPtrTests
{
    // Doesn't test marshalling, this is tested in raw MarshalledPtr tests. I wanted to save some time, so these tests are autogenerated.

    [Fact]
    public void Can_Create()
    {
        var value = 42;
        var memory = new Reloaded.Memory.Memory();
        var ptr = new SourcedMarshalledPtr<int, Reloaded.Memory.Memory>((byte*)&value, memory);
        ((nuint)ptr.Pointer.Pointer).Should().NotBe(new UIntPtr(0));
        ((nuint)ptr.Pointer.Pointer).Should().Be((nuint)(&value));
        ptr.Source.Should().Be(memory);
    }

    [Fact]
    public void Can_Equals()
    {
        var value = 42;
        var memory = new Reloaded.Memory.Memory();
        var ptr1 = new SourcedMarshalledPtr<int, Reloaded.Memory.Memory>((byte*)&value, memory);
        var ptr2 = new SourcedMarshalledPtr<int, Reloaded.Memory.Memory>((byte*)&value, memory);
        ptr1.Should().Be(ptr2);
        (ptr1 == ptr2).Should().BeTrue();
    }

    [Fact]
    public void Can_InEquality()
    {
        var value1 = 42;
        var value2 = 24;
        var memory = new Reloaded.Memory.Memory();
        var ptr1 = new SourcedMarshalledPtr<int, Reloaded.Memory.Memory>((byte*)&value1, memory);
        var ptr2 = new SourcedMarshalledPtr<int, Reloaded.Memory.Memory>((byte*)&value2, memory);
        ptr1.Should().NotBe(ptr2);
        (ptr1 != ptr2).Should().BeTrue();
    }

    [Fact]
    public void Can_GetSet()
    {
        var value = 42;
        var newValue = 24;
        var memory = new Reloaded.Memory.Memory();
        var ptr = new SourcedMarshalledPtr<int, Reloaded.Memory.Memory>((byte*)&value, memory);
        var read = ptr.Get();
        read.Should().Be(value);
        ptr.Set(in newValue);
        read = ptr.Get();
        read.Should().Be(newValue);
    }

    [Fact]
    public void Can_GetSetWithIndex()
    {
        var values = stackalloc int[3] { 1, 2, 3 };
        var memory = new Reloaded.Memory.Memory();
        var ptr = new SourcedMarshalledPtr<int, Reloaded.Memory.Memory>((byte*)values, memory);
        var read = ptr.Get(1);
        read.Should().Be(2);
        var newValue = 24;
        ptr.Set(1, in newValue);
        read = ptr.Get(1);
        read.Should().Be(newValue);
    }

    [Fact]
    public void Can_AddSubtract()
    {
        var values = stackalloc int[3] { 1, 2, 3 };
        var memory = new Reloaded.Memory.Memory();
        SourcedMarshalledPtr<int, Reloaded.Memory.Memory> sourcedPointer = new((byte*)&values[0], memory);
        SourcedMarshalledPtr<int, Reloaded.Memory.Memory> newPointer = sourcedPointer + 1;
        ((nuint)newPointer.Pointer.Pointer).Should().Be((nuint)(&values[1]));
        newPointer -= 1;
        ((nuint)newPointer.Pointer.Pointer).Should().Be((nuint)(&values[0]));
    }

    [Fact]
    public void Can_TrueFalse()
    {
        var value = 42;
        Reloaded.Memory.Memory source = new();
        SourcedMarshalledPtr<int, Reloaded.Memory.Memory> sourcedPointer = new((byte*)&value, source);
        if (sourcedPointer) { }
        else Assert.Fail("SourcedPointer should be true!");

        SourcedMarshalledPtr<int, Reloaded.Memory.Memory> nullSourcedPointer = new((byte*)0x0, source);
        if (nullSourcedPointer) Assert.Fail("SourcedPointer should be false!");
    }

    [Fact]
    public void Can_ToString()
    {
        var value = 42;
        Reloaded.Memory.Memory source = new();
        SourcedMarshalledPtr<int, Reloaded.Memory.Memory> sourcedPointer = new((byte*)&value, source);

        var expectedString = $"SourcedMarshalledPtr<Int32, Memory> ({new MarshalledPtr<int>((byte*)&value)})";
        sourcedPointer.ToString().Should().Be(expectedString);
    }
}
