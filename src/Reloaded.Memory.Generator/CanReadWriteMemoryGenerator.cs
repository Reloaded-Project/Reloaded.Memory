using System.Collections.Generic;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Reloaded.Memory.Generator;

[Generator]
public class CanReadWriteMemoryGenerator : ISourceGenerator
{
    public void Initialize(GeneratorInitializationContext context)
        => context.RegisterForSyntaxNotifications(() => new CanReadWriteMemorySyntaxReceiver());

    public void Execute(GeneratorExecutionContext context)
    {
        if (context.SyntaxReceiver is not CanReadWriteMemorySyntaxReceiver syntaxReceiver)
            return;

        Compilation compilation = context.Compilation;

        foreach (StructDeclarationSyntax structDeclaration in syntaxReceiver.StructDeclarations)
        {
            SemanticModel semanticModel = compilation.GetSemanticModel(structDeclaration.SyntaxTree);
            var classSymbol = (ITypeSymbol)semanticModel.GetDeclaredSymbol(structDeclaration);

            if (classSymbol is null || classSymbol.AllInterfaces.IsEmpty)
                continue;

            foreach (INamedTypeSymbol implementedInterface in classSymbol.AllInterfaces)
            {
                if (implementedInterface.ToDisplayString() != "Reloaded.Memory.Interfaces.ICanReadWriteMemory")
                    continue;

                var extensionMethods =
                    GetExtensionMethods(classSymbol.Name, classSymbol.ContainingNamespace.ToDisplayString());
                context.AddSource($"{classSymbol.Name}_srcgen.g.cs",
                    SourceText.From(extensionMethods, Encoding.UTF8));
            }
        }
    }

    private static string GetExtensionMethods(string className, string nameSpace)
    {
        // Replace "TSource" with the className in the provided extension methods
        var stringBuilder = new StringBuilder();
        stringBuilder.AppendLine("// <auto-generated/>");
        stringBuilder.AppendLine($"using {nameSpace};");
        stringBuilder.AppendLine(
            $@"
using Reloaded.Memory.Extensions;
using Reloaded.Memory.Utilities;
using Reloaded.Memory.Exceptions;
using Reloaded.Memory.Interfaces;
using System.Diagnostics.CodeAnalysis;

namespace {nameSpace};
");
        stringBuilder.AppendLine(
            """
#nullable enable
/// <summary>
///     Extension methods for TSource
/// </summary>
[SuppressMessage("Usage", "RS0016:Add public types and members to the declared API", Justification = "Source Generator Shenanigans")]
[SuppressMessage("Interoperability", "CA1416: Validate Platform Compatibility", Justification = "Source Generator Shenanigans")]
public partial struct TSource
{
/// <summary>
///     Reads a generic type from a specified memory address.
/// </summary>
/// <typeparam name="TData">Any unmanaged type.</typeparam>
/// <param name="offset">The memory address/offset to read from.</param>
/// <exception cref="MemoryException">Failed to read memory.</exception>
[MethodImpl(MethodImplOptions.AggressiveInlining)]
[ExcludeFromCodeCoverage]
public TData Read<TData>(nuint offset)
    where TData : unmanaged
{
    TData result = default;
    this.ReadRef(offset, ref result);
    return result;
}

/// <summary>
///     Reads a generic type from a specified memory address.
/// </summary>
/// <typeparam name="TData">Any unmanaged type.</typeparam>
/// <param name="offset">The memory address/offset to read from.</param>
/// <param name="value">Variable to receive the read in struct.</param>
/// <exception cref="MemoryException">Failed to read memory.</exception>
[MethodImpl(MethodImplOptions.AggressiveInlining)]
[ExcludeFromCodeCoverage]
public void Read<TData>(nuint offset, out TData value)
    where TData : unmanaged => value = this.Read<TData>(offset);

/// <summary>
///     Reads a generic type from a specified memory address; using Marshalling.
/// </summary>
/// <typeparam name="TData">
///     An individual struct type of a class with an explicit <see cref="StructLayoutAttribute" />
///     attribute.
/// </typeparam>
/// <param name="offset">The memory address to read from.</param>
/// <param name="value">Local variable to receive the read in struct.</param>
/// <exception cref="MemoryException">Failed to read memory.</exception>
[MethodImpl(MethodImplOptions.AggressiveInlining)]
[ExcludeFromCodeCoverage]
public void ReadWithMarshallingOutParameter<
#if NET5_0_OR_GREATER
    [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicConstructors |
                                DynamicallyAccessedMemberTypes.NonPublicConstructors)]
#endif
    TData>(nuint offset, [DisallowNull] out TData? value)
    where TData : new()
{
    value = this.ReadWithMarshalling<TData>(offset);
}

/// <summary>
///     Reads a generic type from a specified memory address; using Marshalling.
/// </summary>
/// <typeparam name="TData">
///     An individual struct type of a class with an explicit <see cref="StructLayoutAttribute" />
///     attribute.
/// </typeparam>
/// <param name="offset">The memory address to read from.</param>
/// <exception cref="MemoryException">Failed to read memory.</exception>
[MethodImpl(MethodImplOptions.AggressiveInlining)]
[ExcludeFromCodeCoverage]
public TData ReadWithMarshalling<
#if NET5_0_OR_GREATER
    [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicConstructors |
                                DynamicallyAccessedMemberTypes.NonPublicConstructors)]
#endif
    TData>(nuint offset) where TData : new()
{
    TData result = new();
    this.ReadWithMarshalling(offset, ref result);
    return result!;
}

/// <summary>
///     Reads raw data from a specified memory address.
/// </summary>
/// <param name="offset">The memory address to read from.</param>
/// <param name="length">Number of bytes to place in returned array.</param>
/// <exception cref="MemoryException">Failed to read memory.</exception>
/// <remarks>
///     This method is provided for convenience. It is recommended you use the Span overload instead.
/// </remarks>
[MethodImpl(MethodImplOptions.AggressiveInlining)]
[ExcludeFromCodeCoverage]
public byte[] ReadRaw(nuint offset, int length)
{
    byte[] result = Polyfills.AllocateUninitializedArray<byte>(length);
    this.ReadRaw(offset, result.AsSpanFast());
    return result;
}
}
"""
        );

        return stringBuilder.ToString().Replace("TSource", className);
    }
}

public class CanReadWriteMemorySyntaxReceiver : ISyntaxReceiver
{
    public List<StructDeclarationSyntax> StructDeclarations { get; } = new();

    public void OnVisitSyntaxNode(SyntaxNode syntaxNode)
    {
        if (syntaxNode is StructDeclarationSyntax classDeclaration)
            StructDeclarations.Add(classDeclaration);
    }
}
